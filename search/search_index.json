{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-learning-php-laravel","title":"Welcome to Learning PHP Laravel","text":"<p>Author: Tran Huy</p> <p>This is a repository for learning Laravel. It is a collection of notes and code snippets that I have collected while learning Laravel. I hope it will be useful for you.</p>"},{"location":"Agile-Scrum/","title":"Agile - Scrum","text":""},{"location":"Agile-Scrum/#roles","title":"Roles","text":"<p>Product Owner:</p> <p>Scrum Master</p> <p>Dev Team</p>"},{"location":"Agile-Scrum/#process","title":"Process","text":"<ul> <li>Product Owner creates a Product Backlog (list of features) or updates an existing one. The features in the product backlog called User Stories.</li> <li>Product Owner prioritizes the Product Backlog</li> <li>Scrum Master creates a Sprint Backlog (list of features to be implemented in the next sprint)</li> <li>Scrum Master creates a Sprint (timebox, usually 2 weeks)</li> <li>Dev Team implements the features in the Sprint Backlog</li> <li>Dev Team meets daily for a Daily Scrum (15 minutes)</li> <li>Dev Team demonstrates the implemented features to client in a Sprint Review (1 hour)</li> <li>Dev Team meets for a Sprint Retrospective (1 hour)</li> <li>Scrum Master creates a new Sprint Backlog</li> <li>Repeat</li> </ul>"},{"location":"Advanced/Queues/","title":"Queues","text":""},{"location":"Advanced/Queues/#introduction","title":"Introduction","text":"<p>Laravel allows you to easily create <code>queued jobs</code> that may be processed in the background. By moving time intensive tasks to a queue, your application can respond to web requests with blazing speed and provide a better user experience to your customers.</p> <p>Laravel queues provide a unified queueing API across a variety of different queue backends, such as Amazon SQS, Redis, or even a relational database</p> <p>Configuration options for Laravel's queue services are stored in the <code>config/queue.php</code> configuration file.</p>"},{"location":"Advanced/Queues/#connections-vs-queues","title":"Connections vs Queues","text":"<p>In your <code>config/queue.php</code> configuration file, there is a <code>connections</code> configuration array. This option defines the connections to backend queue services such as Amazon SQS, Beanstalk, or Redis.</p> <p>Note that each connection configuration example in the queue <code>configuration</code> file contains a <code>queue</code> attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection.</p> <pre><code>'connections' =&gt; [\n\n        'sync' =&gt; [\n            'driver' =&gt; 'sync',\n        ],\n\n        'database' =&gt; [\n            'driver' =&gt; 'database',\n            'table' =&gt; 'jobs',\n            'queue' =&gt; 'default',\n            'retry_after' =&gt; 90,\n            'after_commit' =&gt; false,\n        ],\n\n        'beanstalkd' =&gt; [\n            'driver' =&gt; 'beanstalkd',\n            'host' =&gt; 'localhost',\n            'queue' =&gt; 'default',\n            'retry_after' =&gt; 90,\n            'block_for' =&gt; 0,\n            'after_commit' =&gt; false,\n        ],\n\n        'sqs' =&gt; [\n            'driver' =&gt; 'sqs',\n            'key' =&gt; env('AWS_ACCESS_KEY_ID'),\n            'secret' =&gt; env('AWS_SECRET_ACCESS_KEY'),\n            'prefix' =&gt; env('SQS_PREFIX', 'https://sqs.us-east-1.amazonaws.com/your-account-id'),\n            'queue' =&gt; env('SQS_QUEUE', 'default'),\n            'suffix' =&gt; env('SQS_SUFFIX'),\n            'region' =&gt; env('AWS_DEFAULT_REGION', 'us-east-1'),\n            'after_commit' =&gt; false,\n        ],\n\n        'redis' =&gt; [\n            'driver' =&gt; 'redis',\n            'connection' =&gt; 'default',\n            'queue' =&gt; env('REDIS_QUEUE', 'default'),\n            'retry_after' =&gt; 90,\n            'block_for' =&gt; null,\n            'after_commit' =&gt; false,\n        ],\n\n    ],\n</code></pre> <p>For example, creating a connection named <code>create_booking</code> that uses the <code>rabbitmq</code> driver and a <code>create_booking</code> queue, you may do the following:</p> <pre><code>'create_booking' =&gt; [\n            'driver' =&gt; 'rabbitmq',\n            'queue' =&gt; 'create_booking',\n            'connection' =&gt; PhpAmqpLib\\Connection\\AMQPLazyConnection::class,\n\n            'hosts' =&gt; [\n                [\n                    'host' =&gt; env('RABBITMQ_HOST', '127.0.0.1'),\n                    'port' =&gt; env('RABBITMQ_VIBE_PORT', 5672),\n                    'user' =&gt; env('RABBITMQ_USER', 'guest'),\n                    'password' =&gt; env('RABBITMQ_PASSWORD', 'guest'),\n                    'vhost' =&gt; env('RABBITMQ_VHOST', '/'),\n                ],\n            ],\n\n            'options' =&gt; [\n                'ssl_options' =&gt; [\n                    'cafile' =&gt; env('RABBITMQ_SSL_CAFILE'),\n                    'local_cert' =&gt; env('RABBITMQ_SSL_LOCALCERT'),\n                    'local_key' =&gt; env('RABBITMQ_SSL_LOCALKEY'),\n                    'verify_peer' =&gt; env('RABBITMQ_SSL_VERIFY_PEER', true),\n                    'passphrase' =&gt; env('RABBITMQ_SSL_PASSPHRASE'),\n                ],\n                'queue' =&gt; [\n                    'job' =&gt; App\\Jobs\\CreateBookingConsumerJob::class,\n                    'exchange' =&gt; 'create_booking',\n                    'exchange_type' =&gt; AMQPExchangeType::FANOUT,\n                    'exchange_routing_key' =&gt; '',\n                ],\n                'heartbeat' =&gt; 10,\n            ],\n\n            /*\n             * Set to \"horizon\" if you wish to use Laravel Horizon.\n             */\n            'worker' =&gt; env('RABBITMQ_WORKER', 'default'),\n        ],\n</code></pre>"},{"location":"Advanced/Queues/#rabbitmq-explained","title":"RabbitMQ Explained","text":"<p>In Rabbitmq, there are 3 main components:</p> <ul> <li> <p>Producer: A producer is an application that sends messages. The producer doesn't know if a message is actually delivered to a queue. It just sends messages to a broker and forgets about it. The producer publish the message to an exchange with a <code>routing key</code>. The <code>routing key</code> is used to route the message to the specified queue.</p> </li> <li> <p>Exchange: A message routing agent that routes messages to queues. It is responsible for receiving messages from producers and routing them to queues. It is not possible to send messages directly to a queue. Instead, producers send messages to an exchange and the exchange routes them to one or more queues.</p> </li> <li> <p>Queue: A buffer that stores messages whose main purpose is to hold messages until they are consumed. When a message is published to an exchange, the exchange routes it to one or more queues. Queues are bound to exchanges with a <code>binding key</code>. The <code>binding key</code> and <code>routing key</code> is used to route the message to the specified queue.</p> </li> <li> <p></p> </li> </ul>"},{"location":"Architecture/Facades/","title":"Facades","text":"<p>Facades provide a static interface to classes that are available in the application's service container.</p> <p>Laravel facades serve as a <code>static proxies</code> to underlying classes in the service container, providing the benefit of a terse, expressive syntax while maintaining more testability and flexibility than traditional static methods.</p> <p>All of Laravel's facades are defined in the <code>Illuminate\\Support\\Facades</code> namespace. So, we can easily access a facade like so:</p> <pre><code>use Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/cache', function () {\n    return Cache::get('key');\n});\n</code></pre>"},{"location":"Architecture/Facades/#helper-function","title":"Helper function","text":"<p>To complement Facades, Laravel offers a variety of global \"helper functions\" that make it even easier to interact with common Laravel features.</p> <p>Some of the common helper functions you may interact with are <code>view</code>, <code>response</code>, <code>url</code>, <code>config</code>, and more.</p>"},{"location":"Architecture/Facades/#how-facade-works","title":"How Facade works","text":"<p><code>Facade</code> is a class that provide access to an object from the container. Laravel's facades, and any custom facades you create, will extend the base <code>Illuminate\\Support\\Facades\\Facade</code> class.</p> <p>'Facade' base class of Laravel makes use of the <code>__callStatic</code> magic-method to defer calls from your facade to an object resolved from the container.</p> <p>For example, the following code call the <code>get</code> method on the <code>Cache</code> facade:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\n\n# Import the Cache Facade\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\View\\View;\n\nclass UserController extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     */\n    public function showProfile(string $id): View\n    {\n        $user = Cache::get('user:'.$id);\n\n        return view('profile', ['user' =&gt; $user]);\n    }\n}\n</code></pre> <p>This <code>Cache</code> facade serves as a proxy for accessing the underlying implementation of the Illuminate\\Contracts\\Cache\\Factory interface. Any call made to the <code>Cache</code> facade will be passed to the underlying instance of the <code>Cache</code> binding in the service container.</p> <p>Looking at that <code>Illuminate\\Support\\Facades\\Cache</code> class, you'll see that there is no static method get:</p> <pre><code>class Cache extends Facade\n{\n    /**\n     * Get the registered name of the component.\n     */\n    protected static function getFacadeAccessor(): string\n    {\n        return 'cache';\n    }\n}\n</code></pre> <p>Instead, it extends the base <code>Facade</code> class and define a function called <code>getFacadeAccessor</code> which returns the name of the binding registered in the service container.</p> <p>When a user references any static method on the <code>Cache</code> facade, Laravel resolves the <code>\"cache\"</code> binding from the service container and runs the requested method (in this case, get) against that object.</p> <p>So basically, Facade is like Singleton - it's a static object that you can access from anywhere in your application.</p> <p>When you call a method on a facade, it passed the call to the underlying instance of the class registered in the service container.</p>"},{"location":"Architecture/RequestLifeCycle/","title":"Request Life Cycle","text":"<p>For full documentation visit Laravel.</p>"},{"location":"Architecture/RequestLifeCycle/#life-cycle-overview","title":"Life Cycle Overview","text":""},{"location":"Architecture/RequestLifeCycle/#entry-point","title":"Entry Point","text":"<p>The entry point for all requests to a Laravel application is the <code>public/index.php</code> file. All requests are directed to this file by your web server (Apache / Nginx) configuration. The index.php file doesn't contain much code. Rather, <code>it is a starting point for loading the rest of the framework</code>.</p> <p>The <code>index.php</code> file loads the Composer generated autoloader definition, and then retrieves an instance of the Laravel application from <code>bootstrap/app.php</code>. The first action taken by Laravel itself is to create an instance of the application / service container.</p>"},{"location":"Architecture/RequestLifeCycle/#http-console-kernels","title":"HTTP / Console Kernels","text":"<p>Next, the incoming request is sent to either the <code>HTTP kernel</code> or the <code>console kernel</code>, depending on the type of request that is entering the application. These two kernels serve as the central location that all requests flow through. For now, let's just focus on the HTTP kernel, which is located in <code>app/Http/Kernel.php</code>.</p> <p>Kernel is a central location that all requests flow through.</p>"},{"location":"Architecture/RequestLifeCycle/#http-kernel","title":"HTTP Kernel","text":"<p>Http Kernel is the class that extends <code>Illuminate\\Foundation\\Http\\Kernel</code> class. In here, it defines the <code>bootstrappers</code> and <code>middleware</code> that will be applied before the request is executed.</p> <p>These bootstrappers can be:</p> <ul> <li>Configure Error Handling</li> <li>Configure Logging</li> <li>Configure Environment</li> <li>Handle Exceptions</li> <li>And many other tasks that need to be done before the request is executed.</li> </ul> <p>The HTTP kernel also defines a list of HTTP middleware that all requests must pass through before being handled by the application. By default, these are:</p> <pre><code>protected $middleware = [\n        // \\App\\Http\\Middleware\\TrustHosts::class,\n        \\App\\Http\\Middleware\\TrustProxies::class,\n        \\Illuminate\\Http\\Middleware\\HandleCors::class,\n        \\App\\Http\\Middleware\\PreventRequestsDuringMaintenance::class,\n        \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class,\n        \\App\\Http\\Middleware\\TrimStrings::class,\n        \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class,\n    ];\n</code></pre> <p>The middleware could be:</p> <ul> <li>Read &amp; Write Session</li> <li>Verify CSRF Token</li> <li>Determine whether the application is in maintenance mode</li> </ul> <p>The method signature for the HTTP kernel's handle method is quite simple: it receives a <code>Request</code> and returns a <code>Response</code>. Think of the kernel as being a big black box that represents your entire application. Feed it HTTP requests and it will return HTTP responses.</p> <p>Give the HTTP kernel a request and it will return a response.</p>"},{"location":"Architecture/RequestLifeCycle/#service-providers","title":"Service Providers","text":"<p>One of the most important kernel bootstrapping actions is loading the service providers for your application.</p> <p>Service Workers are responsible for bootstrapping all of the framework's various components, such as the database, queue, validation, and routing components.</p> <p>They are configured in your <code>config/app.php</code> configuration file's <code>providers</code> array.</p> <pre><code>'providers' =&gt; ServiceProvider::defaultProviders()-&gt;merge([\n        /*\n         * Package Service Providers...\n         */\n\n        /*\n         * Application Service Providers...\n         */\n        App\\Providers\\AppServiceProvider::class,\n        App\\Providers\\AuthServiceProvider::class,\n        // App\\Providers\\BroadcastServiceProvider::class,\n        App\\Providers\\EventServiceProvider::class,\n        App\\Providers\\RouteServiceProvider::class,\n    ])-&gt;toArray(),\n</code></pre> <p>Laravel will iterate through this list of providers and instantiate each of them. After instantiating the providers, the <code>register</code> method will be called on all of the providers.</p> <p>Then, once all of the providers have been registered, the <code>boot</code> method will be called on each provider.</p> <p>Essentially every major feature offered by Laravel is bootstrapped and configured by a service provider</p>"},{"location":"Architecture/RequestLifeCycle/#routing","title":"Routing","text":"<p>One of the most important service providers in your application is the <code>App\\Providers\\RouteServiceProvider</code>. This service provider loads the route files contained within your application's <code>routes</code> directory.</p> <p>Here is the boot method of the RouteServiceProvider:</p> <pre><code>    /**\n     * Define your route model bindings, pattern filters, and other route configuration.\n     */\n    public function boot(): void\n    {\n        RateLimiter::for('api', function (Request $request) {\n            return Limit::perMinute(60)-&gt;by($request-&gt;user()?-&gt;id ?: $request-&gt;ip());\n        });\n\n        // 'api' and 'web' are the names of the middleware groups\n        $this-&gt;routes(function () {\n            Route::middleware('api')\n                -&gt;prefix('api')\n                -&gt;group(base_path('routes/api.php'));\n\n            Route::middleware('web')\n                -&gt;group(base_path('routes/web.php'));\n        });\n    }\n</code></pre> <p>Middleware provide a convenient mechanism for filtering or examining HTTP requests entering your application.</p> <p>Some middleware are assigned to all routes within the application, like those defined in the <code>$middleware</code> property of your HTTP kernel, while some are only assigned to specific routes or route groups.</p> <p>If the request passes through all of the matched route's assigned middleware, the route or controller method will be executed and the response returned by the route or controller method will be sent back through the route's chain of middleware.</p> <p>Finally, once the response travels back through the middleware, the HTTP kernel's <code>handle</code> method returns the response object and the index.php file calls the <code>send</code> method on the returned response. The send method sends the response content to the user's web browser. We've finished our journey through the entire Laravel request lifecycle!</p> <p>Middleware -&gt; Route -&gt; Controller -&gt; Middleware -&gt; Http Kernel's handle method -&gt; index.php 's send method -&gt; Response</p>"},{"location":"Architecture/ServiceContainer/","title":"Service Container","text":"<p>The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection.</p> <p>Injecting User Repository into Controller:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Repositories\\UserRepository;\nuse App\\Models\\User;\nuse Illuminate\\View\\View;\n\nclass UserController extends Controller\n{\n    /**\n     * Create a new controller instance.\n     */\n    public function __construct(\n        protected UserRepository $users,\n    ) {}\n\n    /**\n     * Show the profile for the given user.\n     */\n    public function show(string $id): View\n    {\n        $user = $this-&gt;users-&gt;find($id);\n\n        return view('user.profile', ['user' =&gt; $user]);\n    }\n}\n</code></pre>"},{"location":"Architecture/ServiceContainer/#zero-configuration-resolution","title":"Zero Configuration Resolution","text":"<p>If a class has no dependencies or only depends on other concrete classes (not interfaces), the container does not need to be instructed on how to resolve that class.</p> <p>For example, you may place the following code in your <code>routes/web.php</code> file:</p> <pre><code>&lt;?php\n\nclass Service\n{\n    public function __construct()\n    {\n        echo \"Test dependency injection\";\n    }\n}\n\nRoute::get('/', function (Service $service) {\n    die($service::class);\n});\n</code></pre> <p>This will output <code>Test dependency injection</code> even though we did not bind the <code>Service</code> class into the container. The container was able to resolve the class and inject it into the route's closure.</p>"},{"location":"Architecture/ServiceProviders/","title":"Service Providers","text":"<p>Service providers are the central place of all Laravel application bootstrapping. Your own application, as well as all of Laravel's core services, are bootstrapped via service providers.</p> <p>Bootstraping means egistering things, including registering service container bindings, event listeners, middleware, and even routes.</p>"},{"location":"Architecture/ServiceProviders/#writing-service-providers","title":"Writing Service Providers","text":""},{"location":"Architecture/ServiceProviders/#registering-service-providers","title":"Registering Service Providers","text":"<p>Within the <code>register</code> method, you should only bind things into the service container. You should never attempt to register any event listeners, routes, or any other piece of functionality within the <code>register</code> method.</p> <p>Let's take a look at a basic service provider. Within any of your service provider methods, you always have access to the <code>$app</code> property which provides access to the service container:</p> <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Services\\Riak\\Connection;\nuse Illuminate\\Contracts\\Foundation\\Application;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass RiakServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     */\n    public function register(): void\n    {\n        $this-&gt;app-&gt;singleton(Connection::class, function (Application $app) {\n            return new Connection(config('riak'));\n        });\n    }\n}\n</code></pre> <p>This service provider only defines a register method, and uses that method to define an implementation of <code>App\\Services\\Riak\\Connection</code> in the service container.</p> <p><code>$this-&gt;app-&gt;singleton</code> is used to bind a singleton instance of a class to the service container. In this case, the class being bound is Connection.</p> <p>The second argument of singleton is a closure function that will be executed when an instance of Connection is requested from the container.</p>"},{"location":"Architecture/ServiceProviders/#bindings-and-singletons","title":"Bindings and Singletons","text":"<p>If your service provider registers many simple bindings, you may wish to use the bindings and singletons properties instead of manually registering each container binding</p> <pre><code>class AppServiceProvider extends ServiceProvider\n{\n    /**\n     * All of the container bindings that should be registered.\n     *\n     * @var array\n     */\n    public $bindings = [\n        ServerProvider::class =&gt; DigitalOceanServerProvider::class,\n    ];\n\n    /**\n     * All of the container singletons that should be registered.\n     *\n     * @var array\n     */\n    public $singletons = [\n        DowntimeNotifier::class =&gt; PingdomDowntimeNotifier::class,\n        ServerProvider::class =&gt; ServerToolsProvider::class,\n    ];\n}\n</code></pre>"},{"location":"Architecture/ServiceProviders/#boot-method","title":"Boot method","text":"<p>This method is called after all other service providers have been registered, meaning you have access to all other services that have been registered by the framework:</p> <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ComposerServiceProvider extends ServiceProvider\n{\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        View::composer('view', function () {\n            // ...\n        });\n    }\n}\n</code></pre>"},{"location":"Architecture/ServiceProviders/#registering-providers","title":"Registering Providers","text":"<p>All service providers are registered in the config/app.php configuration file</p>"},{"location":"Architecture/ServiceProviders/#deferred-providers","title":"Deferred Providers","text":"<p>If your provider is only registering bindings in the service container, you may choose to defer its registration until one of the registered bindings is actually needed.</p> <p>To defer the loading of a provider, implement the <code>\\Illuminate\\Contracts\\Support\\DeferrableProvider</code> interface and define a provides method. The provides method should return the service container bindings registered by the provider:</p> <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Services\\Riak\\Connection;\nuse Illuminate\\Contracts\\Foundation\\Application;\nuse Illuminate\\Contracts\\Support\\DeferrableProvider;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass RiakServiceProvider extends ServiceProvider implements DeferrableProvider\n{\n    /**\n     * Register any application services.\n     */\n    public function register(): void\n    {\n        $this-&gt;app-&gt;singleton(Connection::class, function (Application $app) {\n            return new Connection($app['config']['riak']);\n        });\n    }\n\n    /**\n     * Get the services provided by the provider.\n     *\n     * @return array&lt;int, string&gt;\n     */\n    public function provides(): array\n    {\n        return [Connection::class];\n    }\n}\n</code></pre>"},{"location":"Basics/Controllers/","title":"Controllers","text":""},{"location":"Basics/Controllers/#basic-controllers","title":"Basic Controllers","text":"<p>To generate a new controller, use the command from Artisan <code>make:controller</code>:</p> <pre><code>php artisan make:controller UserController\n</code></pre> <p>After generating a controller, simply add methods to the class. Once you have written a controller class and method, you may define a route to the controller method like so:</p> <pre><code>use App\\Http\\Controllers\\UserController;\n\nRoute::get('/user/{id}', [UserController::class, 'show']);\n\n</code></pre>"},{"location":"Basics/Controllers/#controllers-middleware","title":"Controllers Middleware","text":"<p>Middleware may be assigned to the controller's routes in your route files:</p> <pre><code>Route::get('profile', [UserController::class, 'show'])-&gt;middleware('auth');\n</code></pre> <p>Or you may make use of the <code>middleware</code> method to assign middleware to the controller's action:</p> <pre><code>class UserController extends Controller\n{\n    /**\n     * Instantiate a new controller instance.\n     */\n    public function __construct()\n    {\n        $this-&gt;middleware('auth');\n        $this-&gt;middleware('log')-&gt;only('index');\n        $this-&gt;middleware('subscribed')-&gt;except('store');\n    }\n}\n</code></pre>"},{"location":"Basics/HTTP/","title":"HTTP Requests","text":""},{"location":"Basics/HTTP/#interacting-with-the-request-and-response","title":"Interacting With The Request and Response","text":"<p>Laravel's <code>Illuminate\\Http\\Request</code> class provides an object-oriented way to interact with the current HTTP request being handled by your application as well as retrieve the input, cookies, and files that were submitted with the request. Us</p> <p>Same for the <code>Illuminate\\Http\\Response</code> class, which is used to build responses to be sent back to the user's browser.</p>"},{"location":"Basics/Middleware/","title":"Middlewares","text":"<p>Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application.</p> <p>Additional middleware can be written to perform a variety of tasks besides authentication. For example, a logging middleware might log all incoming requests to your application.</p>"},{"location":"Basics/Middleware/#defining-middleware","title":"Defining Middleware","text":"<p>Use the command <code>make:middleware</code> to create a new middleware class:</p> <pre><code>php artisan make:middleware EnsureTokenIsValid\n</code></pre> <p>This will generate a middleware class in the <code>app/Http/Middleware</code> directory.</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass EnsureTokenIsValid\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\n     */\n    public function handle(Request $request, Closure $next): Response\n    {\n        if ($request-&gt;input('token') !== 'my-secret-token') {\n            return redirect('home');\n        }\n\n        return $next($request);\n    }\n}\n</code></pre>"},{"location":"Basics/Middleware/#middleware-and-responses","title":"Middleware and Responses","text":"<p>A middleware can intercept both the request and the response.</p> <p>For example, to perform some task before the application handles the incoming request:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass BeforeMiddleware\n{\n    public function handle(Request $request, Closure $next): Response\n    {\n        // Perform action\n\n        return $next($request);\n    }\n}\n</code></pre> <p>To perform some task after the application handles the incoming request:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass AfterMiddleware\n{\n    public function handle(Request $request, Closure $next): Response\n    {\n        $response = $next($request);\n\n        // Perform action\n\n        return $response;\n    }\n}\n</code></pre>"},{"location":"Basics/Middleware/#registering-middleware","title":"Registering Middleware","text":""},{"location":"Basics/Middleware/#global-middleware","title":"Global Middleware","text":"<p>To register a global middleware, use the <code>$middleware</code> property of your <code>app/Http/Kernel.php</code> class.</p> <pre><code>protected $middleware = [\n        // \\App\\Http\\Middleware\\TrustHosts::class,\n        \\App\\Http\\Middleware\\TrustProxies::class,\n        \\Illuminate\\Http\\Middleware\\HandleCors::class,\n        \\App\\Http\\Middleware\\PreventRequestsDuringMaintenance::class,\n        \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class,\n        \\App\\Http\\Middleware\\TrimStrings::class,\n        \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class,\n    ];\n</code></pre>"},{"location":"Basics/Middleware/#assigning-middleware-to-routes","title":"Assigning Middleware To Routes","text":"<p>If you would like to assign middleware to specific routes, you may invoke the middleware method when defining the route:</p> <pre><code>Route::get('/', function () {\n    // ...\n})-&gt;middleware([First::class, Second::class]);\n</code></pre> <p>If you feel like that is too long and complicated, you can use the <code>$middlewareAliases</code> in the <code>app/Http/Kernel.php</code> class to define aliases for your middleware. After that, you can use the alias when defining the route:</p> <pre><code>Route::get('/profile', function () {\n    // ...\n})-&gt;middleware('auth');\n</code></pre>"},{"location":"Basics/Routing/","title":"Routing","text":""},{"location":"Basics/Routing/#basic-routing","title":"Basic Routing","text":"<p>The most basic Laravel routes accept a URI and a closure, providing a very simple and expressive method of defining routes and behavior without complicated routing configuration files:</p> <pre><code>use Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/greeting', function () {\n    return 'Hello World';\n});\n</code></pre>"},{"location":"Basics/Routing/#available-router-methods","title":"Available Router Methods","text":"<pre><code>Route::get($uri, $callback);\nRoute::post($uri, $callback);\nRoute::put($uri, $callback);\nRoute::patch($uri, $callback);\nRoute::delete($uri, $callback);\nRoute::options($uri, $callback);\n</code></pre> <p>For registering a route that responds to multiple HTTP verbs:</p> <pre><code>Route::match(['get', 'post'], '/', function () {\n    // ...\n});\n\nRoute::any('/', function () {\n    // ...\n});\n</code></pre>"},{"location":"Basics/Routing/#parameters","title":"Parameters","text":"<p>Sometimes you will need to capture segments of the URI within your route. For example, you may need to <code>capture a user's ID</code>from the URL. You may do so by defining route parameters:</p> <pre><code>Route::get('/posts/{post}/comments/{comment}', function (string $postId, string $commentId) {\n    // ...\n});\n</code></pre>"},{"location":"Basics/Routing/#optional-parameters","title":"Optional Parameters","text":"<pre><code>Route::get('/user/{name?}', function (?string $name = null) {\n    return $name;\n});\n\nRoute::get('/user/{name?}', function (?string $name = 'John') {\n    return $name;\n});\n</code></pre>"},{"location":"Basics/Routing/#parameters-and-dependency-injection","title":"Parameters and Dependency Injection","text":"<p>If your route has dependencies that you would like the Laravel service container to automatically inject into your route's callback, you should list your route parameters after your dependencies:</p> <pre><code>use Illuminate\\Http\\Request;\n\nRoute::get('/user/{id}', function (Request $request, string $id) {\n    return 'User '.$id;\n});\n</code></pre>"},{"location":"Database/GettingStarted/","title":"Getting Started","text":""},{"location":"Database/GettingStarted/#introduction","title":"Introduction","text":"<p>Almost every modern web application interacts with a database. Laravel makes interacting with databases extremely simple across a variety of supported databases using raw SQL, a fluent query builder, and the Eloquent ORM. Currently, Laravel provides first-party support for five databases:</p> <ul> <li>MariaDB</li> <li>MySQL</li> <li>Postgres</li> <li>SQLite</li> <li>SQL Server</li> </ul>"},{"location":"Database/GettingStarted/#configuration","title":"Configuration","text":"<p>The configuration for Laravel's database services is located in your application's <code>config/database.php</code> configuration file. In this file, you may define all of your database connections, as well as specify which connection should be used by default. Most of the configuration options within this file are driven by the values of your application's environment variables.</p> <pre><code>'mysql' =&gt; [\n            'driver' =&gt; 'mysql',\n            'url' =&gt; env('DATABASE_URL'),\n            'host' =&gt; env('DB_HOST', '127.0.0.1'),\n            'port' =&gt; env('DB_PORT', '3306'),\n            'database' =&gt; env('DB_DATABASE', 'forge'),\n            'username' =&gt; env('DB_USERNAME', 'forge'),\n            'password' =&gt; env('DB_PASSWORD', ''),\n            'unix_socket' =&gt; env('DB_SOCKET', ''),\n            'charset' =&gt; 'utf8mb4',\n            'collation' =&gt; 'utf8mb4_unicode_ci',\n            'prefix' =&gt; '',\n            'prefix_indexes' =&gt; true,\n            'strict' =&gt; true,\n            'engine' =&gt; null,\n            'options' =&gt; extension_loaded('pdo_mysql') ? array_filter([\n                PDO::MYSQL_ATTR_SSL_CA =&gt; env('MYSQL_ATTR_SSL_CA'),\n            ]) : [],\n        ],\n</code></pre> <p>For convenience, Laravel supports these URLs as an alternative to configuring your database with multiple configuration options. If the url (or corresponding <code>DATABASE_URL</code> environment variable) configuration option is present, it will be used to extract the database connection and credential information.</p>"},{"location":"Database/GettingStarted/#read-and-write-connections","title":"Read and Write Connections","text":"<p>Sometimes you may wish to use one database connection for <code>SELECT</code> statements, and another for <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements.</p>"},{"location":"EloquentORM/Factory/","title":"Factory","text":"<p>When <code>testing</code> your application or <code>seeding</code> your database, you may need to insert a few records into your database. Instead of manually specifying the value of each column, Laravel allows you to define a set of default attributes for each of your Eloquent models using model factories.</p> <pre><code>namespace Database\\Factories;\n\nuse Illuminate\\Support\\Str;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass UserFactory extends Factory\n{\n    /**\n     * Define the model's default state.\n     *\n     * @return array&lt;string, mixed&gt;\n     */\n    public function definition(): array\n    {\n        return [\n            'name' =&gt; fake()-&gt;name(),\n            'email' =&gt; fake()-&gt;unique()-&gt;safeEmail(),\n            'email_verified_at' =&gt; now(),\n            'password' =&gt; '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password\n            'remember_token' =&gt; Str::random(10),\n        ];\n    }\n}\n</code></pre> <p>The definition method returns the default set of attribute values that should be applied when creating a model using the factory.</p> <p>Via the <code>fake</code> helper, factories have access to the <code>Faker PHP</code> library, which allows you to conveniently generate various kinds of random data for testing and seeding.</p>"},{"location":"EloquentORM/Factory/#define-models-factory","title":"Define Model's Factory","text":"<pre><code>php artisan make:factory PostFactory\n</code></pre>"},{"location":"EloquentORM/Factory/#creating-the-model-from-factory","title":"Creating the model from factory","text":"<pre><code>use App\\Models\\User;\n\n$user = User::factory()-&gt;make();\n\n// or\n\n$users = User::factory()-&gt;count(3)-&gt;make(); // Returns a collection of 3 models.\n</code></pre>"},{"location":"EloquentORM/GettingStarted/","title":"Getting Started","text":""},{"location":"EloquentORM/GettingStarted/#introduction","title":"Introduction","text":"<p>Eloquent is Laravel's default ORM (Object Relational Mapper). It supports multiple database systems and is built on top of the PDO (PHP Data Objects) database abstraction layer.</p> <p>Currently, Eloquent ORM supports four relational database systems:</p> <ul> <li>MySQL</li> <li>Postgres</li> <li>SQLite</li> <li>SQL Server</li> </ul> <p>Each table of a database will me mapped to one Model class. Models allow you to query for data in your tables, as well as update of the table.</p>"},{"location":"EloquentORM/GettingStarted/#generating-model","title":"Generating Model","text":"<p>To generate a new model, use the command from Artisan <code>make:model</code>:</p> <pre><code>php artisan make:model Flight\n</code></pre> <p>This command will create a new model class in the <code>app/Models</code> directory.</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    use HasFactory;\n}\n</code></pre>"},{"location":"EloquentORM/GettingStarted/#defining-model","title":"Defining Model","text":""},{"location":"EloquentORM/GettingStarted/#tables-name","title":"Table's name","text":"<p>By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified.</p> <p>So the model named Flight will become the table <code>flights</code>. Or you can change the table name by:</p> <pre><code>class Flight extends Model\n{\n    /**\n     * The table associated with the model.\n     *\n     * @var string\n     */\n    protected $table = 'my_flights';\n}\n</code></pre>"},{"location":"EloquentORM/GettingStarted/#primary-keys","title":"Primary Keys","text":"<p>By default, Eloquent expects the primary key of the table to be an auto-incrementing integer named <code>id</code>.</p> <p>Instead of using the default primary key, you can define a protected <code>$primaryKey</code> property on your model:</p> <p>You can also use UUID as primary key:</p> <pre><code>use Illuminate\\Database\\Eloquent\\Concerns\\HasUuids;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Article extends Model\n{\n    use HasUuids;\n\n    // ...\n}\n\n$article = Article::create(['title' =&gt; 'Traveling to Europe']);\n\n$article-&gt;id; // \"8f8e8478-9035-4d23-b9a7-62f4d2612ce5\"\n</code></pre> <p>For more about primary keys, see Eloquent: Getting Started.</p>"},{"location":"EloquentORM/GettingStarted/#timestamps","title":"Timestamps","text":"<p>By default, Eloquent expects created_at and updated_at columns to exist on your model's corresponding database table. Eloquent will automatically set the values of these columns when models are created or updated.</p> <p>You can set the <code>$timestamps</code> property on your model to <code>false</code> to disable this behavior.</p>"},{"location":"EloquentORM/GettingStarted/#retrieving-models","title":"Retrieving Models","text":"<p>You can think of each Eloquent model as a powerful query builder allowing you to fluently query the database table associated with the model.</p> <p>The model's all method will retrieve all of the records from the model's associated database table:</p> <pre><code>use App\\Models\\Flight;\n\nforeach (Flight::all() as $flight) {\n    echo $flight-&gt;name;\n}\n</code></pre> <p>Since each Eloquent model serves as a query builder, you may add additional constraints to queries and then invoke the get method to retrieve the results:</p> <pre><code>$flights = Flight::where('active', 1)\n               -&gt;orderBy('name')\n               -&gt;take(10)\n               -&gt;get();\n</code></pre>"},{"location":"EloquentORM/GettingStarted/#refreshing-models","title":"Refreshing models","text":"<p>If you already have an instance of an Eloquent model that was retrieved from the database, you can \"<code>refresh</code>\" the model using the fresh and refresh methods. The fresh method will <code>re-retrieve</code> the model from the database. The existing model instance will not be affected:</p> <pre><code>$flight = Flight::where('number', 'FR 900')-&gt;first();\n\n$freshFlight = $flight-&gt;fresh();\n</code></pre>"},{"location":"EloquentORM/GettingStarted/#collections","title":"Collections","text":"<p>As we have seen, Eloquent methods like <code>all</code> and <code>get</code> retrieve multiple records from the database. However, these methods don't return a plain PHP array. Instead, an instance of <code>Illuminate\\Database\\Eloquent\\Collection</code> is returned.</p> <p>This Class provides a variety of helpful methods for working with your Eloquent results:</p> <p>For example, <code>reject</code> method may be used to remove items from the collection based on the results of a truth test:</p> <pre><code>$flights = Flight::where('destination', 'Paris')-&gt;get();\n\n$flights = $flights-&gt;reject(function (Flight $flight) {\n    return $flight-&gt;cancelled;\n});\n</code></pre>"},{"location":"EloquentORM/GettingStarted/#chunking-results","title":"Chunking results","text":"<p>Your application may run out of memory if you attempt to load tens of thousands of Eloquent records via the <code>all</code> or <code>get</code> methods. Instead of using these methods, the <code>chunk</code> method may be used to process large numbers of models more efficiently.</p>"},{"location":"EloquentORM/Mutartors%26Casts/","title":"Mutators &amp; Casting","text":""},{"location":"EloquentORM/Mutartors%26Casts/#introduction","title":"Introduction","text":"<p><code>Accessors</code>, <code>mutators</code>, and <code>attribute casting</code> allow you to transform Eloquent attribute values when you retrieve or set them on model instances</p>"},{"location":"EloquentORM/Mutartors%26Casts/#accessors","title":"Accessors","text":""},{"location":"EloquentORM/Mutartors%26Casts/#defining-the-accessor","title":"Defining the Accessor","text":"<p>To define an accessor, create a protected method on your model to represent the accessible attribute. This method name should correspond to the \"camel case\" representation of the true underlying <code>model attribute / database column</code> when applicable.</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Get the user's first name.\n     */\n    protected function firstName(): Attribute\n    {\n        return Attribute::make(\n            get: fn (string $value) =&gt; ucfirst($value),\n        );\n    }\n}\n</code></pre>"},{"location":"EloquentORM/Relationships/","title":"Relationships","text":""},{"location":"EloquentORM/Relationships/#defining-relationship","title":"Defining relationship","text":"<p>Eloquent relationships are <code>defined as methods</code> on your Eloquent model classes. Since relationships also serve as powerful query builders, defining relationships as methods provides powerful method chaining and querying capabilities.</p> <p>For example, we may chain additional query constraints on this posts relationship:</p> <pre><code>$user-&gt;posts()-&gt;where('active', 1)-&gt;get();\n</code></pre>"},{"location":"EloquentORM/Relationships/#one-to-one","title":"One To One","text":"<pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\Relations\\HasOne;\n\nclass User extends Model\n{\n    /**\n     * Get the phone associated with the user.\n     */\n    public function phone(): HasOne\n    {\n        return $this-&gt;hasOne(Phone::class);\n    }\n}\n</code></pre> <p>Dynamic properties allow you to access relationship methods as if they were properties defined on the model:</p> <pre><code>$phone = User::find(1)-&gt;phone;\n</code></pre> <p>If you would like the relationship to use a primary key value <code>other than id or your model's $primaryKey</code> property, you may pass a third argument to the hasOne method:</p> <pre><code>return $this-&gt;hasOne(Phone::class, 'foreign_key', 'local_key');\n</code></pre>"},{"location":"EloquentORM/Relationships/#inverse-of-the-relationship","title":"Inverse Of The Relationship","text":"<pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\n\nclass Phone extends Model\n{\n    /**\n     * Get the user that owns the phone.\n     */\n    public function user(): BelongsTo\n    {\n        return $this-&gt;belongsTo(User::class);\n    }\n}\n</code></pre>"},{"location":"EloquentORM/Serialization/","title":"Serializing Models and Collections","text":""},{"location":"EloquentORM/Serialization/#serializing-to-arrays-and-json","title":"Serializing to arrays and JSON","text":"<p>To convert a model and its loaded relationships <code>to an array</code>, you should use the <code>toArray</code> method. This method is recursive, so all attributes and all relations (including the relations of relations) will be converted to arrays:</p> <pre><code>use App\\Models\\User;\n\n$user = User::with('roles')-&gt;first();\n\nreturn $user-&gt;toArray();\n</code></pre> <p>The same for JSON with the method <code>toJson()</code></p>"},{"location":"EloquentORM/Serialization/#manipulating-the-json","title":"Manipulating the JSON","text":""},{"location":"EloquentORM/Serialization/#hiding-attributes-from-json","title":"Hiding attributes from JSON","text":"<p>You may use the <code>visible</code> property to define an \"allow list\" of attributes that should be included in your model's array and JSON representation.</p> <p>All attributes that are not present in the <code>$visible</code> array will be hidden when the model is converted to an array or JSON:</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be visible in arrays.\n     *\n     * @var array\n     */\n    protected $visible = ['first_name', 'last_name'];\n}\n</code></pre> <p>You can also temporarily add the hidden attributes to the model's visible attributes using the <code>makeVisible</code> method:</p> <pre><code>\nreturn $user-&gt;makeVisible('attribute')-&gt;toArray();\n</code></pre> <p>Likewise for <code>makeHidden</code> method, it used to hide an attribute:</p> <pre><code>return $user-&gt;makeHidden('attribute')-&gt;toArray();\n</code></pre>"},{"location":"EloquentORM/Serialization/#appending-values-to-json","title":"Appending values to JSON","text":"<p>Occasionally, when converting models to arrays or JSON, you may wish to <code>add attributes</code> that do not have a corresponding column in your <code>database</code>. You need to define an accessor for the value;</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Determine if the user is an administrator.\n     */\n    protected function isAdmin(): Attribute\n    {\n        return new Attribute(\n            get: fn () =&gt; 'yes',\n        );\n    }\n}\n</code></pre> <p>Then, you may use the <code>append</code> property to add the value to the model's array or JSON representation:</p> <pre><code>return $user-&gt;append('is_admin')-&gt;toArray();\n\nreturn $user-&gt;setAppends(['is_admin'])-&gt;toArray();\n\n</code></pre>"}]}